# 思路

开始以为是那个经典的动态规划 LCS (Longest Common Subsequence) 问题，仔细看发现不是。

限制 `O(n)` 是最大的难度。

初步考虑用散列排序。虽然 `O(10^9) + O(n)` 依然算 `O(n)`，但实际的速度就过于慢了，内存占用也大。

需要借助哈希表，假设哈希表的查找是 `O(1)` 时间。

难点：

> 如何借助哈希表，判定 consecutive sequence 及其长度。

哈希表的 key 也是无序的。所以对 consecutive sequence 的第一个数和非第一个数要区别对待。

判定是不是第一个数，看其减一是否也在哈希表中。不是第一个数就不用管了。

如果是第一个数，不断加一，直到加出来的数不在哈希表中。

时间复杂度是 O(n)。因为每个序列的第一个数，向后检查的数字个数约等于这个序列的长度，累加起来约等于总数量。
